"use strict";(self.webpackChunkstudio=self.webpackChunkstudio||[]).push([[4849],{3201:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Processes/tiling","title":"Image Tiling","description":"Overview","source":"@site/docs/Processes/tiling.md","sourceDirName":"Processes","slug":"/Processes/tiling","permalink":"/static/docs/docs/Processes/tiling","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Processes/tiling.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Processes","permalink":"/static/docs/docs/category/processes"},"next":{"title":"Annotation and Training Sets","permalink":"/static/docs/docs/Processes/annotation"}}');var s=n(4848),a=n(8453);const l={sidebar_position:1},o="Image Tiling",r={},d=[{value:"Overview",id:"overview",level:2},{value:"Core Implementation",id:"core-implementation",level:2},{value:"Tiling Process Details",id:"tiling-process-details",level:2},{value:"1. Image Loading and Preprocessing",id:"1-image-loading-and-preprocessing",level:3},{value:"2. Tile Generation Strategy",id:"2-tile-generation-strategy",level:3},{value:"3. Tile Size and Naming",id:"3-tile-size-and-naming",level:3},{value:"4. Optional Automatic Segmentation",id:"4-optional-automatic-segmentation",level:3},{value:"5. JSON Annotation Generation",id:"5-json-annotation-generation",level:3},{value:"Tiling Algorithm Visualization",id:"tiling-algorithm-visualization",level:2},{value:"Machine Learning Considerations",id:"machine-learning-considerations",level:2},{value:"1. Tile Size Selection",id:"1-tile-size-selection",level:3},{value:"2. Downsampling Option",id:"2-downsampling-option",level:3},{value:"3. Integration with Segmentation",id:"3-integration-with-segmentation",level:3},{value:"Usage in the ML Pipeline",id:"usage-in-the-ml-pipeline",level:2},{value:"References",id:"references",level:2}];function c(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"image-tiling",children:"Image Tiling"})}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(i.p,{children:["The tiling process in Studio divides large images into smaller tiles that are more manageable for annotation and processing. This document explains the actual implementation from the ",(0,s.jsx)(i.code,{children:"axons-teaching"})," repository."]}),"\n",(0,s.jsx)(i.h2,{id:"core-implementation",children:"Core Implementation"}),"\n",(0,s.jsxs)(i.p,{children:["The tiling functionality is implemented in the ",(0,s.jsx)(i.code,{children:"process_images"})," and ",(0,s.jsx)(i.code,{children:"tile_image"})," functions, which you can find in the ",(0,s.jsx)(i.code,{children:"axons/data/preprocessing.py"})," file:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'def process_images(image_paths, output_folder, downsample=False, model_path=None):\n    """\n    Process a list of images by tiling them into smaller pieces.\n    \n    Parameters:\n    - image_paths: List of paths to input images\n    - output_folder: Where to save the tiles\n    - downsample: Whether to reduce resolution\n    - model_path: Optional path to a segmentation model for automatic mask generation\n    """\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n\n    # Create a subfolder for masks\n    mask_folder = os.path.join(output_folder, "masks")\n    if not os.path.exists(mask_folder):\n        os.makedirs(mask_folder)\n\n    # Save JSON files in the same folder as the tiles\n    json_folder = output_folder\n\n    model = None\n    image_processor = None\n    device = None\n\n    if model_path is not None:\n        model, image_processor, device = load_segmentation_model(model_path)\n        model.eval()\n\n    for image_path in tqdm(image_paths, desc="Processing images"):\n        base_name = os.path.splitext(os.path.basename(image_path))[0]\n        tile_count = 0\n\n        for tile in tile_image(image_path, tile_size=(512, 512), downsample=downsample):\n            # Convert tile to RGB\n            tile_rgb = tile.convert("RGB")\n\n            # Save the original tile\n            tile_name = f"{base_name}_tile_{tile_count:04d}.png"\n            tile_rgb.save(os.path.join(output_folder, tile_name))\n\n            if model is not None:\n                # Process the tile for segmentation\n                inputs = image_processor(images=tile_rgb, return_tensors="pt")\n                inputs = {k: v.to(device) for k, v in inputs.items()}\n\n                with torch.no_grad():\n                    outputs = model(**inputs)\n                    logits = outputs.logits\n                    probs = torch.softmax(logits, dim=1)\n                    tile_mask = (probs[0, 1].cpu().numpy() > 0.5).astype(np.uint8) * 255\n\n                # Save the segmentation mask in the mask subfolder\n                mask_name = f"{base_name}_tile_{tile_count:04d}_mask.png"\n                mask_path = os.path.join(mask_folder, mask_name)\n                Image.fromarray(tile_mask).save(mask_path)\n\n                # Generate and save JSON representation\n                json_name = f"{base_name}_tile_{tile_count:04d}__labels.json"\n                json_path = os.path.join(json_folder, json_name)\n                binary_mask_to_json(tile_mask, json_path, tile_name)\n\n            tile_count += 1\n'})}),"\n",(0,s.jsx)(i.p,{children:"The actual tiling function:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'def tile_image(image_path, tile_size=(500, 500), downsample=False):\n    """\n    Generator function that yields tiles from a large image.\n    \n    Parameters:\n    - image_path: Path to the image to tile\n    - tile_size: Size of each tile (width, height)\n    - downsample: Whether to reduce the image size before tiling\n    \n    Yields:\n    - PIL.Image tiles\n    """\n    image = Image.open(image_path)\n\n    # Optionally downsample large images\n    if downsample:\n        image = image.resize((image.width // 3, image.height // 3), Image.LANCZOS)\n\n    img_width, img_height = image.size\n\n    x_tiles = img_width // tile_size[0]\n    y_tiles = img_height // tile_size[1]\n\n    # Process main grid of tiles\n    for y in range(0, y_tiles * tile_size[1], tile_size[1]):\n        for x in range(0, x_tiles * tile_size[0], tile_size[0]):\n            tile = image.crop((x, y, x + tile_size[0], y + tile_size[1]))\n            yield tile\n\n    # Handle remaining right edge\n    if img_width % tile_size[0] != 0:\n        for y in range(0, y_tiles * tile_size[1], tile_size[1]):\n            tile = image.crop((img_width - tile_size[0], y, img_width, y + tile_size[1]))\n            yield tile\n\n    # Handle remaining bottom edge\n    if img_height % tile_size[1] != 0:\n        for x in range(0, x_tiles * tile_size[0], tile_size[0]):\n            tile = image.crop((x, img_height - tile_size[1], x + tile_size[0], img_height))\n            yield tile\n\n    # Handle bottom-right corner if needed\n    if img_width % tile_size[0] != 0 and img_height % tile_size[1] != 0:\n        tile = image.crop((img_width - tile_size[0], img_height - tile_size[1], img_width, img_height))\n        yield tile\n'})}),"\n",(0,s.jsx)(i.h2,{id:"tiling-process-details",children:"Tiling Process Details"}),"\n",(0,s.jsx)(i.p,{children:"The tiling approach implemented in the code has several important characteristics:"}),"\n",(0,s.jsx)(i.h3,{id:"1-image-loading-and-preprocessing",children:"1. Image Loading and Preprocessing"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Uses PIL (Python Imaging Library) to load images"}),"\n",(0,s.jsxs)(i.li,{children:["Disables maximum image size restrictions with ",(0,s.jsx)(i.code,{children:"Image.MAX_IMAGE_PIXELS = None"})]}),"\n",(0,s.jsxs)(i.li,{children:["Optionally downsamples large images by a factor of 3 using ",(0,s.jsx)(i.code,{children:"Image.LANCZOS"})," resampling"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-tile-generation-strategy",children:"2. Tile Generation Strategy"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"tile_image"})," function implements a systematic approach to dividing images:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Main Grid"}),": Creates a grid of non-overlapping tiles of the specified size"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Edge Handling"}),": Specifically handles the right edge, bottom edge, and bottom-right corner"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Complete Coverage"}),": Ensures the entire image is covered by tiles, with some tiles potentially overlapping at the edges"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"3-tile-size-and-naming",children:"3. Tile Size and Naming"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Default tile size is 512\xd7512 pixels"}),"\n",(0,s.jsxs)(i.li,{children:["Tiles are named systematically: ",(0,s.jsx)(i.code,{children:"{original_filename}_tile_{sequential_number}.png"})]}),"\n",(0,s.jsx)(i.li,{children:"The sequential numbering creates a consistent order for processing"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"4-optional-automatic-segmentation",children:"4. Optional Automatic Segmentation"}),"\n",(0,s.jsx)(i.p,{children:"If a model path is provided, the code can automatically:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Generate segmentation masks for each tile"}),"\n",(0,s.jsx)(i.li,{children:'Save masks as PNG files in a "masks" subfolder'}),"\n",(0,s.jsx)(i.li,{children:"Convert masks to JSON annotation format compatible with the annotation tool"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"5-json-annotation-generation",children:"5. JSON Annotation Generation"}),"\n",(0,s.jsxs)(i.p,{children:["For pre-segmented images, the ",(0,s.jsx)(i.code,{children:"binary_mask_to_json"})," function:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Identifies connected components in the segmentation mask"}),"\n",(0,s.jsx)(i.li,{children:"Converts binary masks to polygon regions"}),"\n",(0,s.jsx)(i.li,{children:"Creates JSON annotation files in the format expected by the annotation tool"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"tiling-algorithm-visualization",children:"Tiling Algorithm Visualization"}),"\n",(0,s.jsx)(i.p,{children:"The tiling approach can be visualized as:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                               \u2502\n\u2502                               \u2502\n\u2502        Original Image         \u2502\n\u2502                               \u2502\n\u2502                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Tile \u2502Tile \u2502Tile \u2502Tile \u2502\u2502Right\u2502\n\u2502 0   \u2502 1   \u2502 2   \u2502 3   \u2502\u2502Edge \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\u2502Tiles\u2502\n\u2502Tile \u2502Tile \u2502Tile \u2502Tile \u2502\u2502     \u2502\n\u2502 4   \u2502 5   \u2502 6   \u2502 7   \u2502\u2502     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\u2502     \u2502\n\u2502Tile \u2502Tile \u2502Tile \u2502Tile \u2502\u2502     \u2502\n\u2502 8   \u2502 9   \u2502 10  \u2502 11  \u2502\u2502     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Bottom Edge Tiles       \u2502\u2502Corner\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(i.p,{children:"The algorithm specifically handles the edges and corner, which is important for images that aren't exact multiples of the tile size."}),"\n",(0,s.jsx)(i.h2,{id:"machine-learning-considerations",children:"Machine Learning Considerations"}),"\n",(0,s.jsx)(i.h3,{id:"1-tile-size-selection",children:"1. Tile Size Selection"}),"\n",(0,s.jsx)(i.p,{children:"The default tile size of 512\xd7512 pixels is chosen because:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"It's compatible with most deep learning architectures"}),"\n",(0,s.jsx)(i.li,{children:"It provides a good balance between context and detail"}),"\n",(0,s.jsx)(i.li,{children:"It fits well in GPU memory during processing"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-downsampling-option",children:"2. Downsampling Option"}),"\n",(0,s.jsx)(i.p,{children:"The optional downsampling (reducing image size by 3\xd7):"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Makes processing extremely large images more manageable"}),"\n",(0,s.jsx)(i.li,{children:"Preserves enough detail for many scientific image analysis tasks"}),"\n",(0,s.jsx)(i.li,{children:"Can significantly reduce processing time and memory usage"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"3-integration-with-segmentation",children:"3. Integration with Segmentation"}),"\n",(0,s.jsx)(i.p,{children:"The tiling process integrates with segmentation by:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Optionally applying a segmentation model to each tile"}),"\n",(0,s.jsx)(i.li,{children:"Generating mask files for each tile"}),"\n",(0,s.jsx)(i.li,{children:"Creating JSON annotations that can be used for training or refinement"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"usage-in-the-ml-pipeline",children:"Usage in the ML Pipeline"}),"\n",(0,s.jsx)(i.p,{children:"In the overall machine learning workflow:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Image Upload"}),": Large images are uploaded to the platform"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Tiling"}),": Images are split into manageable tiles using this process"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Annotation"}),": Users can annotate tiles or refine automatically generated annotations"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Training Set Creation"}),": Selected tiles are grouped into training sets"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Model Training"}),": Models are trained on the annotated tiles"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Inference"}),": Trained models are applied to new images, processed as tiles"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(i.p,{children:["This implementation is found in the following files in the ",(0,s.jsx)(i.code,{children:"axons-teaching"})," repository:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"axons/data/preprocessing.py"})," - Contains the ",(0,s.jsx)(i.code,{children:"process_images"})," and ",(0,s.jsx)(i.code,{children:"tile_image"})," functions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"axons/utils/model_loader.py"})," - Contains the helper function for loading segmentation models"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>o});var t=n(6540);const s={},a=t.createContext(s);function l(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);